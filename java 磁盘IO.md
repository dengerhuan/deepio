NIO的Buffer提供了一个可以不经过JVM内存直接访问系统物理内存的类——DirectBuffer。 DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同，普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存的限制；而DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。

直接内存的读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢（猜测原因是DirectBuffer需向OS申请内存涉及到用户态内核态切换，而后者则直接从堆内存划内存即可）。

因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。

 

（Note：DirectBuffer并没有真正向OS申请分配内存，其最终还是通过调用Unsafe的allocateMemory()来进行内存分配。不过JVM对Direct Memory可申请的大小也有限制，可用-XX:MaxDirectMemorySize=1M设置，这部分内存不受JVM垃圾回收管理。）

 

使用对外内存的原因：

- 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。
- 提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。

 



Java Memory-Mapped File所使用的内存分配在物理内存而不是JVM堆内存，且分配在OS内核。

1：

[内存映射文件及其应用 - 实现一个简单的消息队列 / 计算机程序的思维逻辑](http://mp.weixin.qq.com/s?__biz=MzIxOTI1NTk5Nw==&mid=2650047418&idx=1&sn=9f09a4e517e46d4f452e43f8ecff42bf&chksm=8fde2668b8a9af7e9dfd1d4b93b4811816941b2a61bb7ab411455b36fe6b96ca93a1031d60ce&scene=21#wechat_redirect)

> 在一般的文件读写中，会有两次数据拷贝，一次是从硬盘拷贝到操作系统内核，另一次是从操作系统内核拷贝到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次拷贝，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。
>
> 内存映射文件的另一个重要特点是，它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。**比普通的基于loopback接口的Socket要快10倍。**
>
> 简单总结下，对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，比如数据库系统或繁忙的电子交易系统，或者需要在不同程序间进行共享和通信，那就可以考虑内存映射文件。

 

2、

[为何要在Java中使用内存映射文件（Memory Mapped File）或者MappedByteBuffer](http://itindex.net/detail/49906-java-内存-映射)

> 1）. Java语言通过java.nio包支持内存映射文件和IO。
>
> 2）. 内存映射文件用于对性能要求高的系统中，如繁忙的电子交易系统
>
> 3）. 使用内存映射IO你可以将文件的一部分加载到内存中
>
> 4）. 如果被请求的页面不在内存中，内存映射文件会导致页面错误
>
> 5）. 将一个文件区间映射到内存中的能力取决于内存的可寻址范围。在32位机器中，不能超过4GB，即2^32比特。
>
> 6）. Java中的内存映射文件比流IO要快(译注：对于大文件而言是对的，小文件则未必）
>
> 7）. 用于加载文件的内存在Java的堆内存之外，存在于共享内存中，允许两个不同进程访问文件。顺便说一下，这依赖于你用的是direct还是non-direct字节缓存。
>
> 8）. 读写内存映射文件是操作系统来负责的，因此，即使你的Java程序在写入内存后就挂掉了，只要操作系统工作正常，数据就会写入磁盘。
>
> 9）. Direct字节缓存比non-direct字节缓存性能要好
>
> 10）. 不要经常调用MappedByteBuffer.force()方法，这个方法强制操作系统将内存中的内容写入硬盘，所以如果你在每次写内存映射文件后都调用force()方法，你就不能真正从内存映射文件中获益，而是跟disk IO差不多。
>
> 11）. 如果电源故障或者主机瘫痪，有可能内存映射文件还没有写入磁盘，意味着可能会丢失一些关键数据。
>
> 12）. MappedByteBuffer和文件映射在缓存被GC之前都是有效的。sun.misc.Cleaner可能是清除内存映射文件的唯一选择。

 

3、Java内存映射文件

　　Java NIO的FileChannel 类提供了一个名为 map( )的方法，该方法可以在一个打开的文件和一个特殊类型的 ByteBuffer 之间建立一个虚拟内存映射，由 map( )方法返回的 MappedByteBuffer 对象的行为类似与基于内存的缓冲区，只不过该对象的数据元素存储在磁盘上的文件中。**通过内存映射机制来访问一个文件会比使用常规方法读写高效得多，甚至比使用通道的效率都高。**

映射方法： buffer = fileChannel.map(MapMode.READ_WRITE, 0, fileChannel.size()); 

- 映射模式：MapMode.READ_WRITE、MapMode.READ_ONLY、MapMode.PRIVATE
- 请求的映射模式将受被调用 map( )方法的 FileChannel 对象的访问权限所限制。如：若通道以只读的权限打开的却请求 MapMode.READ_WRITE 模式，则map( )方法会抛出一个 NonWritableChannelException 异常
- MapMode.PRIVATE模式表示一个写时拷贝（ copy-on-write）的映射，这意味着通过 put( )方法所做的任何修改都会导致产生一个私有的数据拷贝并且该拷贝中的数据只有MappedByteBuffer 实例可以看到。该过程不会对底层文件做任何修改，而且一旦缓冲区被施以垃圾收集动作（ garbage collected），那些修改都会丢失。

通过内存映射文件简单实现持久化消息队列：

![点击全屏显示](assets/ContractedBlock.gif) View Code

 





1、内存映射文件

读文件时候一般要两次复制：从磁盘复制到内核空间再复制到用户空间，内存映射文件避免了第二次复制，且内存分配在内核空间，应用程序访问的就是操作系统的内核内存空间，因此极大提高了读取效率。写文件同理。

2、堆内存分配与直接内存分配：

Java申请空间时通常是从JVM堆内存分配的，即 ByteBuffer.allocate(int capacity) ，但其实还可以直接从物理内存（用户空间内存？）分配，即 ByteBuffer.allocateDirect(int capacity) ，后者其实调用了Unsafe类进行分配（见下节）。后者的分配原理是这样的：使用Native函数库直接分配堆外内存，通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，从而避免了在java堆和Native堆之间复制数据的开销。

通常来说，由于后者避免了数据在堆外内存和JVM堆内存间的复制，所以读写性能比前者的好，但是后者的分配比前者慢，特别是在数据量大的情况下差别更明显。此外，直接内存常被用来扩展可用的内存区域。

比较：

